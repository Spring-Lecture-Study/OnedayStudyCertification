# 19532. 수학은 비대면강의입니다[B2]
---

### 🌐 문제 링크:

https://www.acmicpc.net/problem/19532

# 💻 문제 설명

- 
    
    정수 a, b, c, d, e, f 를 주어졌을 때, 
    
    ax + by = c
    
    dx + ey = f
    
    해당 연립방정식에서 x, y의 값을 계산하여 출력하는 문제이다.
    

# **💡 풀이 과정**

- 
    
    ## 문제 접근
    
    ### 다른 사람의 접근 방법
    
    이 문제는 x와 y가 정수해로 제하되었고, 탐색 범위도 -999, 999까지 총 1999, 시간복작도는 
    
    O(N2)O(N^2) O(N2)에 해당하며, N=1999 라 하더라도 현대 컴퓨터로는 충분히 처리 가능하기 때문에 브루트 포스 즉 완전 탐색으로 해결하면 된다.
    
    # ✏️ **풀이 코드**
    
    - 이중 for문을 통해 x, y에 들어갈 수 있는 모든 수를 넣어서 조건에 만족하는 값이 나온다면 결과를 출력하면 된다.
        
        ```python
        a, b, c, d, e, f = map(int, input().split())
        
        for x in range(-999, 1000):
            for y in range(-999, 1000):
                if (a * x) + (b * y) == c and (d * x) + (e * y) == f:
                    print(x, y)
        ```
        
    
    ### 다른 사람의 접근 방법2
    
    너무 완전 탐색으로 접근 하는 거 같아서 다른 방법을 찾아보니, 아래처럼 X자 모양으로 수를 곱한 뒤 나눠지면 쉽게 x, y값을 구할 수 있다고 합니다.
    
   ![image](https://github.com/user-attachments/assets/1b638602-550d-4ddc-ad9e-5256a64cb27b)
    
    출처: https://ssafy-story.tistory.com/68
    
    # ✏️ **풀이 코드**
    
    ```python
    a, b, c, d, e, f = map(int, input().split())
    
    x = (c * e - b * f) // (a * e - b * d)
    y = (c * d - a * f) // (b * d - a * e)
    print(x, y)
    ```
    

# 📒 **풀이 후기**

수학에 약한 내가 오랜만에 연립방정식을 풀려고 하니 구하는 공식을 까먹어서 결국에 구글링을 통해 찾아보게 됐다. 그래서 여러 방법을 봤지만, 해당 방법을 코딩으로 구현하지 못하고 다른 사람들에 코드를 보게되었다. 이때 브루트 포스에 대해 알게 되었는데, 브루트 포스는 완전 탐색이라고 하며 이번 문제처럼 x, y 값이 정수인 해만 요구하고 범위가 -999~999 즉, 1999개 이중 for문으로 접근한다면 

O(N2)에 해당하며, N=1999라 하더라도 그리 큰 숫자가 아니기 때문에 완전 탐색으로 구현된다고 한다. 

이 방법 외 시간 복잡도를 줄이기 위해 가감법을 사용하는 방법도 있지만, 여러 방면으로 많이 부족하다는 것을 느끼고 문제를 많이 풀고 복습해야겠다.

---
# 1018. 체스판 다시 칠하기[S4]

### 🌐 문제 링크:

https://www.acmicpc.net/problem/1018

# 💻 문제 설명

- 
    
    지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M*N크기의 보드를 찾았다.
    
    보드판의 정사각형은 **검은색** 또는 **흰색**으로 번갈아서 칠해져 있다. 지민이는 이러한 보드를 잘라서 8*8 크기의 체스판을 만들려고 한다.
    
    보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 
    
    지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.
    

# **💡 풀이 과정**

- 
    
    ## 문제 접근
    
    ### 8x8 보드판을 어떻게 자를지 정해진 게 없기 때문에 모든 경우의 수를 확인해야 한다.
    
    주어진 N * M 보드판에서 8*8 체스판을 선택하는 모든 가능한 시작점을 탐색한다.
    
    - 행의 시작점은 **M-7**, 열의 시작점은 **N-7** 로 범위를 설정한다.
    - -7을 하는 이유는 체스판의 크기가 8 * 8이고, 인덱스는 0부터 시작하기 때문에 보드판의 크기를 초과하지 않기 위해 -7로 설정한다.
    
    ### 비교 방법
    
     각 부분 체스판을 두 가지 패턴과 비교하여 칠해야 하는 칸의 개수를 계산한다.
    
    체스판은 "맨 왼쪽 위 칸이 **흰색**"으로 시작하거나 "**검은색**"으로 시작하는 두 가지 경우가 있다.
    
    8 * 8 부분 체스판의 각 칸을 두 패턴과 하나씩 비교하며, 현재 체스판에서 다시 칠해야 하는 칸의 개수를 계산한다.
    
    이렇게 각각의 체스판에서 계산한 값을 저장하고, 다음 체스판으로 넘어갈 때 현재 최소값과 비교하여 갱신한다.
    
    모든 체스판을 탐색한 뒤, 저장된 최소값을 출력한다.
    
    # ✏️ **풀이 코드**
    
    ```python
    N, M = map(int, input().split())
    board = [input() for _ in range(N)]
    
    # 체스판 패턴 정의
    chess_W = [
        "WBWBWBWB",
        "BWBWBWBW",
        "WBWBWBWB",
        "BWBWBWBW",
        "WBWBWBWB",
        "BWBWBWBW",
        "WBWBWBWB",
        "BWBWBWBW",
    ]
    
    chess_B = [
        "BWBWBWBW",
        "WBWBWBWB",
        "BWBWBWBW",
        "WBWBWBWB",
        "BWBWBWBW",
        "WBWBWBWB",
        "BWBWBWBW",
        "WBWBWBWB",
    ]
    
    # 최소값 초기화
    min_paint = float("inf")
    
    # 모든 8x8 체스판을 탐색
    for i in range(N - 7):  # 가능한 행 시작점
        for j in range(M - 7):  # 가능한 열 시작점
            paint_W = 0  # W로 시작하는 체스판과의 차이
            paint_B = 0  # B로 시작하는 체스판과의 차이
    
            # 8x8 체스판 체크
            for x in range(8):
                for y in range(8):
                    if board[i + x][j + y] != chess_W[x][y]:
                        paint_W += 1
                    if board[i + x][j + y] != chess_B[x][y]:
                        paint_B += 1
            # 최소값 갱신
            min_paint = min(min_paint, paint_W, paint_B)
    print(min_paint)
    ```
    

## 📋 주요 코드 설명

```python
 # 8x8 체스판 체크
        for x in range(8):
            for y in range(8):
                if board[i + x][j + y] != chess_W[x][y]:
                    paint_W += 1
                if board[i + x][j + y] != chess_B[x][y]:
                    paint_B += 1
```

행과 열의 시작점을 기준으로 8×8 크기의 부분 체스판을 탐색하며, 각 칸의 색을 두 가지 패턴(맨 왼쪽 위가 흰색인 경우와 검은색인 경우)과 비교한다. 이 과정에서 색이 다른 칸의 개수를 각각 계산하여, 패턴과의 차이를 확인한다.

체스판 패턴은, 아래와 같이 방법들로 정의해도 상관없다. 

```python
str1 = "WBWBWBWB"
str2 = "BWBWBWBW"
chess_W = [str1, str2, str1, str2, str1, str2, str1, str2] 
chess_B = [str2, str1, str2, str1, str2, str1, str2, str1]
```

패턴을 정의하지 않고 행과 열의 합에 따라 색상을 비교하는 방법

```prolog
if (a + b) % 2 == 0:  # 행과 열의 합이 짝수인 경우
    if board[a][b] != 'B':  # 이 칸이 검은색(B)이 아니면 다시 칠해야 함
        draw1 += 1
    if board[a][b] != 'W':  # 이 칸이 흰색(W)이 아니면 다시 칠해야 함 (다른 패턴 가정)
        draw2 += 1
else:  # 행과 열의 합이 홀수인 경우
    if board[a][b] != 'W':  # 이 칸이 흰색(W)이 아니면 다시 칠해야 함
        draw1 += 1
    if board[a][b] != 'B':  # 이 칸이 검은색(B)이 아니면 다시 칠해야 함 (다른 패턴 가정)
        draw2 += 1
```

https://ittrue.tistory.com/60

체스판은 각 칸의 색상이 **행과 열의 합**에 따라 번갈아 칠해지는 규칙

- **짝수 칸**: 검은색(B) 또는 흰색(W).
- **홀수 칸**: 그 반대의 색상.

# 📒 **풀이 후기**

처음 풀었을 때 실버 문제가 많이 어렵다는 것을 느꼈지만, gpt에 설명을 듣다보니 나의 문제해결 능력이 부족했다는 것을 뼈저리게 느꼈다. 부족하더라도 하루에 한문제씩 풀면서, 문제해결 방법을 생각하는 것과 이것을 python으로 구현하는 것을 할양해야 될 것 같다.
