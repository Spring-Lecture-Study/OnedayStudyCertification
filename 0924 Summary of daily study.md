#1859. 백만 장자 프로젝트 [D2]
# 💻 문제 설명

- 
    
    원재는 미래를 보는 능력을 가지고 있다. 이 능력을 사용하여 사재기를 해서 최대한 이득을 얻을려고 한다.
    
    사재기를 할 때 다음과 같은 조건이 있다.
    
    1. 원재는 연속된 N일 동안의 물건의 매매가를 예측하여 알고 있다.
    2. 당국의 감시망에 걸리지 않기 위해 하루에 최대 1만큼 구입할 수 있다.
    3. 판매는 얼마든지 할 수 있다.
    
    이러한 조건들을 만족하는 방법을 사용해서 최대한 이득을 얻어야 한다.
    
    ![image](https://github.com/user-attachments/assets/e6b913f3-db5f-413a-a065-2d9272a76d57)
    

# **💡 풀이 과정**

최대한에 이득을 얻을려면 제일 비쌀 때 파는 것이 좋기 때문에, 매매가를 오름 차순으로 정렬한 후 매매가와 비교하여 마지막 값(제일 큰 값)과 비교했을 때 같지 않다면 사고, 같은 값이라면 팔고 맨 마지막 값 요소를 제거해서 다음 큰 값과 비교하는 방식을 사용할려고 했다.

하지만 테케1 처럼 제일 큰 값이 앞에 오면 사지도 않고 팔게 되기 때문에 다른 사람에 코드를 참조하게 됐다. 

[https://herbi1411.tistory.com/entry/SWEA-백만-장자-프로젝트1859-PYTHON](https://herbi1411.tistory.com/entry/SWEA-%EB%B0%B1%EB%A7%8C-%EC%9E%A5%EC%9E%90-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B81859-PYTHON)

> 배열의 끝 요소부터 앞으로 가면서 현재까지의 최댓값을 저장하며  현재 요소가 최댓값보다 작다면 그 차이를 정답 값에 더하는 방식(물건 구매)으로 계산하면 되겠다는 생각을 했다. 현재 요소가 최댓값보다 크다면, 최댓값을 갱신하고 다음 요소로 넘어간다.
> 

## 📋 주요 코드 설명

```java
for val in ls[::-1]:
        if val >= mp:
            mp = val
        else:
            ans += mp - val
```

**[::-1]**은 리스트를 역순으로 순환을 하기 때문에, N일 동안에 매매가를 역순으로 순환한다.

그러면서 현재 요소의 값과 최고값을 비교했을 때 크거나 같다면 현재 요소를 최고값으로 갱신하고, 그렇지 않다면 그 차이를 결과값에 더하여 누적한다.

# ✏️ **풀이 코드**

```java
T = int(input())
 
for tc in range(1, T + 1):
    n = int(input())
    ls = list(map(int, input().split()))
    mp = 0
    ans = 0
    for val in ls[::-1]:
        if val >= mp:
            mp = val
        else:
            ans += mp - val
    print(f'#{tc} {ans}')
```

# 📒 **풀이 후기**

오랜만에 SWEA에 문제를 풀다보니 제출하는 양식과 방법을 다시 익힐 수 있었고, [::-1] 같은 리스트의 역순환 방법을 알게되는 문제였다.

# 📝 새로 알게된 것

✅ [::-1]은 **거꾸로 순환**하는 새로운 리스트를 반환하게 된다.

다만, [-1]은 리스트의 마지막 요소 하나를 가져오는 인덱싱이기 때문에 헷갈리면 안된다.

# 1954. 달팽이 숫자 [D2]
# 💻 문제 설명

- 
    
    달팽이는 1부터 N*N까지의 숫자가 시계방향으로 이루어져 있다.
    
    정수 N을 입력 받아 N크기의 달팽이를 출력하시오.
    

# **💡 풀이 과정**

1부터 N*N까지의 숫자를 달팽이 모양으로, 즉 시계방향으로 배열하는 문제이다.
2차원 배열을 N*N 크기로 초기화하였고, 이동할 방향을 결정하기 위한 방향 벡터를 사용하였다.

그래서 움직이면서 숫자값을 갱신하면서 이미 숫자가 채워진 칸이나 배열의 경계에 도달하면 방향을 바꿔 다음 방향으로 이동하도록 하여 시계방향으로 움직이겠금 설계하였다.

## 📋 주요 코드 설명

```java
nx, ny = x + dx[dr], y + dy[dr]
if 0 <= nx < n and 0 <= ny < n and snail[nx][ny] == 0:
    x,y = nx, ny
    snail[x][y] = cnt
    cnt += 1
else:
    dr = (dr+1) % 4
```

현재 좌표 x, y 에서 방향 벡터를 더하고 이 좌표가 숫자가 채워진 칸이나 배열의 경계에 도달 했는지 확인한다. 조건문에 해당한다면, 현재 좌표를 nx, ny로 업데이트하고 해당 칸에 cnt 값을 할당한 뒤, cnt 값을 1 증가시킨다.

만약 조건에 해당하지 않는다면, 배열의 경계에 도달했거나 이미 숫자가 채워진 칸에 도달했음을 의미하므로, 방향을 바꾸기 위해 dr 값을 1 증가시켜 새로운 방향으로 전환한다. 

- dr 값은 4로 나눈 나머지를 사용해 0~3 사이에서 순환하도록 하여, 시계방향으로 계속 이동할 수 있게 한다.

# ✏️ **풀이 코드**

```java
T = int(input())
# 방향 벡터 좌표
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

for tc in range(1, T+1):
    n = int(input())
    snail = [[0] * n for _ in range(n)]
    x, y, cnt, dr = 0, 0, 1, 0
    snail[x][y] = cnt
    cnt += 1
    while cnt <= n * n:
        nx, ny = x + dx[dr], y + dy[dr]
        if 0 <= nx < n and 0 <= ny < n and snail[nx][ny] == 0:
            x,y = nx, ny
            snail[x][y] = cnt
            cnt += 1
        else:
            dr = (dr+1) % 4
    print(f'#{tc}')
    for row in snail:
        print(*row)
```
